{"version":3,"sources":["../src/asyncOperationUtils.js"],"names":["alwaysImmutable","initialReadAsyncOperation","fetchStatus","FETCH_STATUS","NULL","dataStatus","DATA_STATUS","ABSENT","message","lastFetchStatusTime","lastFetchFailed","lastDataStatusTime","initialWriteAsyncOperation","initialReadAsyncOperationForAction","descriptorId","fieldsToAdd","parentAsyncOperation","readAsyncOperationFieldsToPullFromParent","initialWriteAsyncOperationForAction","beginReadAsyncOperation","previousAsyncOperation","fieldsForNewAsyncOperation","PENDING","Date","now","PRESENT","Object","assign","beginWriteAsyncOperation","initialAsyncOperation","resolveReadAsyncOperation","currentTime","fieldsToUpdate","SUCCESSFUL","resolveWriteAsyncOperation","rejectReadAsyncOperation","FAILED","rejectWriteAsyncOperation"],"mappings":"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","sourcesContent":["// @flow\n// TODO: JSDocify every function\n\nimport { pick } from 'lodash';\n\nimport {\n  readAsyncOperationFieldsToPullFromParent,\n  FETCH_STATUS,\n  DATA_STATUS,\n} from './constants';\n\n// An asyncOperation is an object that tracks the status of some data that we fetch from\n// somewhere or send to somewhere. Each asyncOperation represents\n// a single 'dataset' (which, today, always means a single ajax request -- although that's\n// not a fixed constraint), and they're stored in Redux under operation-specific keys.\n//\n// \"read\" and \"write\" operations are *slightly* different, but they work the same way.\n//\n// The asyncOperation tracks information about:\n//  - Our last attempt to fetch or write the data\n//  - Whether we have data from a prior successful attempt (for reads only)\n//  - The action and params and such that were used to request the data\n//\n// This file includes standalone functions that transform asyncOperations when we\n// begin, resolve, or reject requests. In general, only reducers should use these functions.\n\n\n/**\n * asyncOperations were originally always treated as proper immutable objects, but for background refreshes\n * it doesn't make sense to create a new object unless the status is actually different somehow, because\n * the new object will cause any screens that select the asyncOperation to rerender.\n *\n * So this is an experiment in having the asyncOperation object be *semi*-immutable: it will only yield\n * a new object instance if there's a noteworthy change in status.\n *\n * @type {boolean}\n */\nconst alwaysImmutable = false;\n\n\n/**\n * This is the default look of brand new, never-touched asyncOperation.\n */\nconst initialReadAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: FETCH_STATUS.NULL,\n  dataStatus: DATA_STATUS.ABSENT,\n  message: null,\n  lastFetchStatusTime: 0,\n  lastFetchFailed: false,\n  lastDataStatusTime: 0,\n};\n\n\nconst initialWriteAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: FETCH_STATUS.NULL,\n  message: null,\n  lastFetchStatusTime: 0,\n};\n\n// Note that we'll pull in any status (dataStatus, fetchStatus, etc) from the parent\n// operation (which *should* be fetchAllBeveragesForOrg) to seed the initial status.\nconst initialReadAsyncOperationForAction = (\n  descriptorId,\n  fieldsToAdd = {},\n  parentAsyncOperation = null,\n) => ({\n  ...initialReadAsyncOperation,\n  ...(parentAsyncOperation ? pick(parentAsyncOperation, readAsyncOperationFieldsToPullFromParent) : {}),\n  ...fieldsToAdd,\n  descriptorId,\n});\n\nconst initialWriteAsyncOperationForAction = (\n  descriptorId,\n  fieldsToAdd = {},\n) => ({\n  ...initialWriteAsyncOperation,\n  ...fieldsToAdd,\n  descriptorId,\n});\n\n/**\n * These are intended for use in reducers, when a __BEGIN action comes in:\n * For read operations, we'll retain any prior dataStatus, but everything else gets reset.\n * Write operations are always a new, blank backendAsyncOperation.\n *\n * Note that you'll always want to specify `descriptorId` in fieldsToAdd, along with any IDs.\n */\nconst beginReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const fieldsForNewAsyncOperation = {\n    // We re-initialize the entire operation state (except descriptorId and dataStatus) on __BEGIN.\n    // (resolve/reject *don't* re-initialize: they carry through any IDs or other fields from before)\n    descriptorId: previousAsyncOperation.descriptorId,\n    fetchStatus: FETCH_STATUS.PENDING,\n    dataStatus: previousAsyncOperation.dataStatus,\n    message: null,\n    lastFetchStatusTime: Date.now(),\n    lastDataStatusTime: previousAsyncOperation.lastDataStatusTime,\n    ...fieldsToAdd,\n  };\n  if (alwaysImmutable || previousAsyncOperation.dataStatus !== DATA_STATUS.PRESENT) {\n    return fieldsForNewAsyncOperation;\n  }\n  Object.assign(previousAsyncOperation, fieldsForNewAsyncOperation);\n  return previousAsyncOperation;\n};\n// Note that the 'write' works the same way as 'read', but instead of calling the base\n// operation \"previousAsyncOperation\" we call it \"initialAsyncOperation\" since its role is different.\nconst beginWriteAsyncOperation = (\n  initialAsyncOperation = initialWriteAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  descriptorId: initialAsyncOperation.descriptorId,\n  fetchStatus: FETCH_STATUS.PENDING,\n  message: null,\n  lastFetchStatusTime: Date.now(),\n  ...fieldsToAdd,\n});\n\n/**\n * These are intended for use in reducers, when a __RESOLVE action comes in:\n * we'll mark that we have data, and will overwrite any prior data status.\n */\nconst resolveReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const currentTime = Date.now();\n  const fieldsToUpdate = {\n    fetchStatus: FETCH_STATUS.SUCCESSFUL,\n    dataStatus: DATA_STATUS.PRESENT,\n    lastFetchStatusTime: currentTime,\n    lastFetchFailed: false,\n    lastDataStatusTime: currentTime,\n    ...fieldsToAdd,\n  };\n  if (alwaysImmutable || previousAsyncOperation.lastFetchFailed || previousAsyncOperation.dataStatus !== DATA_STATUS.PRESENT) {\n    return {\n      ...previousAsyncOperation,\n      ...fieldsToUpdate,\n    };\n  }\n  // Else: we already had data, and we weren't asked to be immutable, so this isn't a noteworthy change,\n  // so mutate in place. (Eep)\n  Object.assign(previousAsyncOperation, fieldsToUpdate);\n  return previousAsyncOperation;\n};\n\nconst resolveWriteAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const currentTime = Date.now();\n  return {\n    ...previousAsyncOperation,\n    fetchStatus: FETCH_STATUS.SUCCESSFUL,\n    lastFetchStatusTime: currentTime,\n    ...fieldsToAdd,\n  };\n};\n\n/**\n * These are intended for use in reducers, when a __REJECT action comes in:\n * we'll mark that things failed, but won't alter any prior data status (if it's a read).\n *\n * Note that you'll almost always want to specify `message` in fieldsToAdd.\n */\nconst rejectReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  ...previousAsyncOperation,\n  fetchStatus: FETCH_STATUS.FAILED,\n  lastFetchStatusTime: Date.now(),\n  lastFetchFailed: true,\n  ...fieldsToAdd,\n});\n\nconst rejectWriteAsyncOperation = (\n  previousAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  ...previousAsyncOperation,\n  fetchStatus: FETCH_STATUS.FAILED,\n  lastFetchStatusTime: Date.now(),\n  ...fieldsToAdd,\n});\n\n\nexport {\n  initialReadAsyncOperationForAction,\n  initialWriteAsyncOperationForAction,\n  beginReadAsyncOperation,\n  beginWriteAsyncOperation,\n  resolveReadAsyncOperation,\n  resolveWriteAsyncOperation,\n  rejectReadAsyncOperation,\n  rejectWriteAsyncOperation,\n};\n"],"file":"asyncOperationUtils.js"}